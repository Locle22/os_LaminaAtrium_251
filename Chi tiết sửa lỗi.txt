================================================================================
                    CHI TIáº¾T CÃC Lá»–I ÄÃƒ Sá»¬A TRONG Dá»° ÃN OS SIMULATION
================================================================================

TÃ¡c giáº£: GitHub Copilot
NgÃ y: 10/12/2025

================================================================================
Má»¤C Lá»¤C
================================================================================
1. Lá»—i 1: Thiáº¿u Ä‘á»‹nh nghÄ©a TABLE_SIZE_64
2. Lá»—i 2: Sai cÃ¡ch truy cáº­p mm_struct (caller->mm thay vÃ¬ caller->krnl->mm)
3. Lá»—i 3: Thiáº¿u cÃ¡c trÆ°á»ng tracking trong struct mm_struct
4. Lá»—i 4: Sai kiá»ƒu tráº£ vá» cá»§a cÃ¡c hÃ m (int thay vÃ¬ addr_t)
5. Lá»—i 5: Typo PAGING64_PAGE_ALIGNSZ_64
6. Lá»—i 6: Race condition trong ld_routine
7. Lá»—i 7: print_pgtbl khÃ´ng in ra PDG=, P4g=, PUD=, PMD=
8. Lá»—i 8: Segfault trong find_victim_page khi FIFO list chá»‰ cÃ³ 1 page
9. Lá»—i 9: Sai format output - print_pgtbl vÃ  libread khÃ´ng khá»›p expected
10. Lá»—i 10: print_pgtbl in header trá»‘ng vÃ  race condition trong cÃ¡c hÃ m lib
11. Lá»—i 11: CÃ¡c process chia sáº» cÃ¹ng má»™t mm_struct (global krnl->mm)
12. Lá»—i 12: sbrk khÃ´ng Ä‘Æ°á»£c update sau khi allocation
13. Lá»—i 13: Sai logic cpu_routine - Post-check vs Pre-check timing
14. Lá»—i 14: Race condition trong timer_routine - Time slot in sau CPU operations

================================================================================
Lá»–I 1: THIáº¾U Äá»ŠNH NGHÄ¨A TABLE_SIZE_64
================================================================================

ğŸ“ File: include/mm64.h

âŒ NGUYÃŠN NHÃ‚N:
--------------
Macro TABLE_SIZE_64 Ä‘Æ°á»£c sá»­ dá»¥ng trong mm64.c nhÆ°ng chÆ°a Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a.
Macro nÃ y xÃ¡c Ä‘á»‹nh sá»‘ entry trong má»—i cáº¥p cá»§a page table (512 entries cho 64-bit).

Lá»—i compiler:
    error: 'TABLE_SIZE_64' undeclared (first use in this function)

â“ Táº I SAO Cáº¦N 512?
-------------------
Trong kiáº¿n trÃºc x86-64 vá»›i 5-level paging:
- Má»—i entry trong page table lÃ  8 bytes (64-bit)
- Má»—i page table cÃ³ kÃ­ch thÆ°á»›c 4KB (4096 bytes)
- Sá»‘ entry = 4096 / 8 = 512 entries

âœ… CÃCH Sá»¬A:
------------
ThÃªm Ä‘á»‹nh nghÄ©a macro vÃ o mm64.h:

    #define TABLE_SIZE_64 512

================================================================================
Lá»–I 2: SAI CÃCH TRUY Cáº¬P MM_STRUCT
================================================================================

ğŸ“ File: src/mm64.c (8 vá»‹ trÃ­)

âŒ NGUYÃŠN NHÃ‚N:
--------------
Code sá»­ dá»¥ng caller->mm nhÆ°ng trong cáº¥u trÃºc pcb_t, mm_struct náº±m trong
krnl (kernel) chá»© khÃ´ng pháº£i trá»±c tiáº¿p trong pcb_t.

Cáº¥u trÃºc thá»±c táº¿:
    struct pcb_t {
        ...
        struct krnl_context_t *krnl;  // Pointer to kernel context
        ...
    };

    struct krnl_context_t {
        ...
        struct mm_struct *mm;  // Memory management structure á»Ÿ Ä‘Ã¢y!
        ...
    };

Lá»—i compiler:
    error: 'struct pcb_t' has no member named 'mm'
    note: did you mean 'krnl'?

â“ VÃ Dá»¤ Cá»¤ THá»‚:
----------------
TRÆ¯á»šC (sai):
    mm->used_pgd[pgd_idx] = 1;
    caller->mm->access_counter++;

SAU (Ä‘Ãºng):
    mm->used_pgd[pgd_idx] = 1;
    caller->krnl->mm->access_counter++;

âœ… CÃC Vá»Š TRÃ ÄÃƒ Sá»¬A:
---------------------
1. vmap_page_range():     caller->mm->access_counter++
2. vmap_page_range():     caller->mm->byte_counter += size
3. alloc_pages_range():   caller->mm->access_counter++
4. alloc_pages_range():   caller->mm->byte_counter += nr_pages * PAGING64_PAGESZ
5. vm_map_ram():          caller->mm->access_counter++
6. vm_map_ram():          caller->mm->byte_counter += size
7. init_mm():             caller->mm->access_counter = 0
8. init_mm():             caller->mm->byte_counter = 0

Táº¥t cáº£ Ä‘á»u Ä‘á»•i thÃ nh caller->krnl->mm->...

================================================================================
Lá»–I 3: THIáº¾U CÃC TRÆ¯á»œNG TRACKING TRONG STRUCT MM_STRUCT
================================================================================

ğŸ“ File: include/os-mm.h

âŒ NGUYÃŠN NHÃ‚N:
--------------
Code trong mm64.c sá»­ dá»¥ng cÃ¡c trÆ°á»ng Ä‘á»ƒ theo dÃµi viá»‡c sá»­ dá»¥ng page table
nhÆ°ng cÃ¡c trÆ°á»ng nÃ y chÆ°a Ä‘Æ°á»£c khai bÃ¡o trong struct mm_struct.

Lá»—i compiler:
    error: 'struct mm_struct' has no member named 'used_pgd'
    error: 'struct mm_struct' has no member named 'used_p4d'
    error: 'struct mm_struct' has no member named 'used_pud'
    error: 'struct mm_struct' has no member named 'used_pmd'
    error: 'struct mm_struct' has no member named 'access_counter'
    error: 'struct mm_struct' has no member named 'byte_counter'

â“ Má»¤C ÄÃCH Cá»¦A CÃC TRÆ¯á»œNG:
---------------------------
- used_pgd[512]: ÄÃ¡nh dáº¥u PGD entry nÃ o Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng
- used_p4d[512]: ÄÃ¡nh dáº¥u P4D entry nÃ o Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng
- used_pud[512]: ÄÃ¡nh dáº¥u PUD entry nÃ o Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng
- used_pmd[512]: ÄÃ¡nh dáº¥u PMD entry nÃ o Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng
- access_counter: Äáº¿m sá»‘ láº§n truy cáº­p memory
- byte_counter: Äáº¿m tá»•ng sá»‘ byte Ä‘Ã£ allocate

âœ… CÃCH Sá»¬A:
------------
ThÃªm cÃ¡c trÆ°á»ng vÃ o struct mm_struct trong os-mm.h:

    struct mm_struct {
        ...
        /* Tracking arrays for page table usage */
        int used_pgd[512];
        int used_p4d[512];
        int used_pud[512];
        int used_pmd[512];
        
        /* Counters for memory access statistics */
        unsigned long access_counter;
        unsigned long byte_counter;
    };

================================================================================
Lá»–I 4: SAI KIá»‚U TRáº¢ Vá»€ Cá»¦A CÃC HÃ€M
================================================================================

ğŸ“ File: src/mm64.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
CÃ¡c hÃ m vmap_page_range(), alloc_pages_range(), vm_map_ram() Ä‘Æ°á»£c khai bÃ¡o
tráº£ vá» kiá»ƒu int nhÆ°ng thá»±c táº¿ tráº£ vá» Ä‘á»‹a chá»‰ (addr_t).

Lá»—i compiler:
    error: conflicting types for 'vmap_page_range'
    error: conflicting types for 'alloc_pages_range'
    error: conflicting types for 'vm_map_ram'

â“ Táº I SAO PHáº¢I LÃ€ addr_t?
--------------------------
- CÃ¡c hÃ m nÃ y tráº£ vá» Ä‘á»‹a chá»‰ áº£o Ä‘Ã£ Ä‘Æ°á»£c map
- addr_t lÃ  unsigned long (64-bit trÃªn há»‡ thá»‘ng 64-bit)
- int chá»‰ cÃ³ 32-bit, khÃ´ng Ä‘á»§ chá»©a Ä‘á»‹a chá»‰ 64-bit

âœ… CÃCH Sá»¬A:
------------
TRÆ¯á»šC:
    int vmap_page_range(...)
    int alloc_pages_range(...)
    int vm_map_ram(...)

SAU:
    addr_t vmap_page_range(...)
    addr_t alloc_pages_range(...)
    addr_t vm_map_ram(...)

================================================================================
Lá»–I 5: TYPO PAGING64_PAGE_ALIGNSZ_64
================================================================================

ğŸ“ File: src/libmem.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
Macro bá»‹ viáº¿t sai tÃªn: PAGING64_PAGE_ALIGNSZ_64 thay vÃ¬ PAGING64_PAGE_ALIGNSZ

Lá»—i compiler:
    error: implicit declaration of function 'PAGING64_PAGE_ALIGNSZ_64'

âœ… CÃCH Sá»¬A:
------------
TRÆ¯á»šC:
    inc_sz = PAGING64_PAGE_ALIGNSZ_64(size);

SAU:
    inc_sz = PAGING64_PAGE_ALIGNSZ(size);

================================================================================
Lá»–I 6: RACE CONDITION TRONG LD_ROUTINE
================================================================================

ğŸ“ File: src/os.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
Trong ld_routine (loader thread), vÃ²ng láº·p chá» time slot Ä‘Æ°á»£c Ä‘áº·t SAU
lá»‡nh load(). Äiá»u nÃ y dáº«n Ä‘áº¿n process Ä‘Æ°á»£c load TRÆ¯á»šC khi Ä‘áº¿n time slot
chÃ­nh xÃ¡c.

â“ VÃ Dá»¤ Cá»¤ THá»‚:
----------------
Náº¿u process Ä‘Æ°á»£c schedule load táº¡i time slot 5:

TRÆ¯á»šC (sai):
    load(...)                    // Load ngay! (cÃ³ thá»ƒ Ä‘ang á»Ÿ slot 3)
    while(current_time() < 5);   // Chá» sau khi Ä‘Ã£ load
    
    Output sai:
    Time slot   3
        Loaded a process at input/proc/p1s, PID: 3 PRIO: 0   <-- Load sá»›m!
    Time slot   4
    Time slot   5

SAU (Ä‘Ãºng):
    while(current_time() < 5);   // Chá» trÆ°á»›c
    load(...)                    // Load Ä‘Ãºng time slot
    
    Output Ä‘Ãºng:
    Time slot   3
    Time slot   4
    Time slot   5
        Loaded a process at input/proc/p1s, PID: 3 PRIO: 0   <-- ÄÃºng slot!

âœ… CÃCH Sá»¬A:
------------
Di chuyá»ƒn vÃ²ng láº·p while LÃŠN TRÆ¯á»šC lá»‡nh load():

TRÆ¯á»šC:
    if (ld_processes.path[i]) {
        ...
        load(...);
        while (current_time() < ld_processes.start_time[i]);
        ...
    }

SAU:
    if (ld_processes.path[i]) {
        ...
        /* Wait until the correct time slot BEFORE loading */
        while (current_time() < ld_processes.start_time[i]);
        load(...);
        ...
    }

NgoÃ i ra, thÃªm fflush(stdout) sau má»—i printf Ä‘á»ƒ Ä‘áº£m báº£o output Ä‘Æ°á»£c
in theo Ä‘Ãºng thá»© tá»± (trÃ¡nh race condition giá»¯a cÃ¡c thread).

================================================================================
Lá»–I 7: PRINT_PGTBL KHÃ”NG IN RA PDG=, P4g=, PUD=, PMD=
================================================================================

ğŸ“ File: src/mm64.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
ÄÃ¢y lÃ  lá»—i NGHIÃŠM TRá»ŒNG NHáº¤T vÃ  phá»©c táº¡p nháº¥t!

Trong hÃ m init_mm(), vm_freerg_list Ä‘Æ°á»£c khá»Ÿi táº¡o vá»›i TOÃ€N Bá»˜ khÃ´ng gian
Ä‘á»‹a chá»‰ áº£o (tá»« 0 Ä‘áº¿n vm_end) nhÆ° lÃ  vÃ¹ng "free":

    struct vm_rg_struct *first_rg = init_vm_rg(vma0->vm_start, vma0->vm_end);
    enlist_vm_rg_node(&vma0->vm_freerg_list, first_rg);

â“ Táº I SAO ÄÃ‚Y LÃ€ SAI?
----------------------
1. vm_freerg_list dÃ¹ng Ä‘á»ƒ quáº£n lÃ½ vÃ¹ng nhá»› ÄÃƒ ÄÆ¯á»¢C ALLOCATED vÃ  SAU ÄÃ“ FREED
2. Khi má»›i khá»Ÿi táº¡o, CHÆ¯A CÃ“ vÃ¹ng nÃ o Ä‘Æ°á»£c map váº­t lÃ½
3. Viá»‡c Ä‘Æ°a toÃ n bá»™ khÃ´ng gian vÃ o free list lÃ m hÃ m get_free_vmrg_area()
   LUÃ”N LUÃ”N tÃ¬m Ä‘Æ°á»£c vÃ¹ng trá»‘ng

â“ Háº¬U QUáº¢:
-----------
Khi __alloc() Ä‘Æ°á»£c gá»i:

1. get_free_vmrg_area() tÃ¬m trong free list -> THÃ€NH CÃ”NG (vÃ¬ toÃ n bá»™ lÃ  "free")
2. Allocation Ä‘Æ°á»£c thá»±c hiá»‡n tá»« free list
3. KHÃ”NG Gá»ŒI syscall Ä‘á»ƒ tÄƒng sbrk vÃ  map physical pages
4. sbrk váº«n = 0
5. print_pgtbl(start=0, end=sbrk) -> khÃ´ng in gÃ¬ vÃ¬ start == end

Flow trong __alloc():
    
    if (get_free_vmrg_area(...) == 0) {   // LuÃ´n thÃ nh cÃ´ng!
        // Allocate tá»« free list
        // KHÃ”NG map physical memory
        return 0;
    }
    
    // Code bÃªn dÆ°á»›i KHÃ”NG BAO GIá»œ Ä‘Æ°á»£c cháº¡y!
    syscall(17, SYSMEM_INC_OP);  // TÄƒng sbrk, map pages
    ...

â“ VÃ Dá»¤ Cá»¤ THá»‚:
----------------
TRÆ¯á»šC (sai):
    init_mm():
        vm_freerg_list = [0 -> 1TB]  // ToÃ n bá»™ lÃ  "free"
        sbrk = 0
    
    __alloc(300 bytes):
        get_free_vmrg_area() -> tÃ¬m Ä‘Æ°á»£c region [0-300] tá»« free list
        Tráº£ vá» Ä‘á»‹a chá»‰ 0
        KHÃ”NG gá»i syscall
        sbrk váº«n = 0
    
    print_pgtbl(0, sbrk=0):
        // start=0, end=0 -> khÃ´ng iterate
        Output: "print_pgtbl: start=0 end=0"
        // KHÃ”NG cÃ³ PDG=, P4g=, ...

SAU (Ä‘Ãºng):
    init_mm():
        vm_freerg_list = NULL  // KhÃ´ng cÃ³ vÃ¹ng free
        sbrk = 0
    
    __alloc(300 bytes):
        get_free_vmrg_area() -> THáº¤T Báº I (free list rá»—ng)
        Gá»i syscall(17, SYSMEM_INC_OP)
        -> inc_vma_limit() Ä‘Æ°á»£c gá»i
        -> vm_map_ram() map physical pages
        -> sbrk = 4096 (page-aligned)
        Tráº£ vá» Ä‘á»‹a chá»‰ 0
    
    print_pgtbl(0, sbrk=4096):
        // start=0, end=4096 -> iterate qua pages
        Output: "print_pgtbl: start=0 end=4096"
        Output: " PDG=0x... P4g=0x... PUD=0x... PMD=0x..."

âœ… CÃCH Sá»¬A:
------------
TRÆ¯á»šC:
    vma0->sbrk = vma0->vm_start;
    struct vm_rg_struct *first_rg = init_vm_rg(vma0->vm_start, vma0->vm_end);
    enlist_vm_rg_node(&vma0->vm_freerg_list, first_rg);

SAU:
    vma0->sbrk = vma0->vm_start;
    /* Do NOT initialize vm_freerg_list with the entire address space!
     * Free list should only contain regions that were previously 
     * allocated and then freed.
     * Initially, all allocation should go through inc_vma_limit 
     * to properly map physical pages.
     */
    vma0->vm_freerg_list = NULL;

================================================================================
Lá»–I 8: SEGFAULT TRONG FIND_VICTIM_PAGE
================================================================================

ğŸ“ File: src/libmem.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
HÃ m find_victim_page() dÃ¹ng thuáº­t toÃ¡n FIFO Ä‘á»ƒ tÃ¬m victim page (trang cÅ© nháº¥t
Ä‘á»ƒ swap out khi háº¿t RAM). Code gá»‘c cÃ³ bug khi FIFO list chá»‰ cÃ³ 1 page.

Code gá»‘c (cÃ³ bug):
    int find_victim_page(struct mm_struct *mm, addr_t *retpgn)
    {
        struct pgn_t *pg = mm->fifo_pgn;
        
        if (!pg) return -1;
        
        struct pgn_t *prev = NULL;
        while (pg->pg_next) {      // Duyá»‡t Ä‘áº¿n cuá»‘i list
            prev = pg;
            pg = pg->pg_next;
        }
        *retpgn = pg->pgn;
        prev->pg_next = NULL;      // BUG! prev cÃ³ thá»ƒ lÃ  NULL
        free(pg);
        return 0;
    }

Lá»—i runtime:
    Thread 4 "os" received signal SIGSEGV, Segmentation fault.
    find_victim_page (mm=0x7fffe800f970, retpgn=0x7ffff5bfbd38) at src/libmem.c:551
    551       prev->pg_next = NULL;

â“ PHÃ‚N TÃCH CHI TIáº¾T:
----------------------
FIFO list lÃ  danh sÃ¡ch liÃªn káº¿t cÃ¡c page Ä‘Ã£ Ä‘Æ°á»£c load vÃ o RAM theo thá»© tá»±:
    
    fifo_pgn -> [page má»›i nháº¥t] -> [page] -> ... -> [page cÅ© nháº¥t] -> NULL
    
Thuáº­t toÃ¡n FIFO cáº§n tÃ¬m page CÅ¨ NHáº¤T (cuá»‘i list) Ä‘á»ƒ swap out.

Váº¥n Ä‘á» xáº£y ra khi FIFO list chá»‰ cÃ³ 1 page:
    
    fifo_pgn -> [page duy nháº¥t] -> NULL
                     |
                     pg (ban Ä‘áº§u)
                     pg->pg_next == NULL

    1. pg = mm->fifo_pgn                    // pg trá» Ä‘áº¿n page duy nháº¥t
    2. prev = NULL                          // prev khá»Ÿi táº¡o NULL
    3. while (pg->pg_next) {...}            // pg->pg_next == NULL, KHÃ”NG vÃ o loop
    4. prev->pg_next = NULL                 // prev == NULL -> CRASH!

â“ TRÆ¯á»œNG Há»¢P BÃŒNH THÆ¯á»œNG (2+ pages):
-------------------------------------
    fifo_pgn -> [page1] -> [page2] -> [page3] -> NULL
                   |          |          |
                  pg      pg->next   pg->next->next
                  
    VÃ²ng láº·p while:
    - Láº§n 1: prev=page1, pg=page2
    - Láº§n 2: prev=page2, pg=page3 (pg->next==NULL, dá»«ng)
    
    Káº¿t quáº£: prev=page2, pg=page3 (victim)
    prev->pg_next = NULL Ä‘Ãºng (ngáº¯t page3 khá»i list)

â“ TRÆ¯á»œNG Há»¢P Lá»–I (1 page):
---------------------------
    fifo_pgn -> [page1] -> NULL
                   |
                  pg
                  
    VÃ²ng láº·p while:
    - pg->pg_next == NULL ngay tá»« Ä‘áº§u, KHÃ”NG cháº¡y vÃ²ng láº·p
    
    Káº¿t quáº£: prev=NULL (khÃ´ng Ä‘Æ°á»£c gÃ¡n), pg=page1
    prev->pg_next = NULL  -> SEGFAULT!

âœ… CÃCH Sá»¬A:
------------
ThÃªm xá»­ lÃ½ Ä‘áº·c biá»‡t cho trÆ°á»ng há»£p chá»‰ cÃ³ 1 page:

TRÆ¯á»šC (cÃ³ bug):
    int find_victim_page(struct mm_struct *mm, addr_t *retpgn)
    {
        struct pgn_t *pg = mm->fifo_pgn;
        
        if (!pg) return -1;
        
        struct pgn_t *prev = NULL;
        while (pg->pg_next) {
            prev = pg;
            pg = pg->pg_next;
        }
        *retpgn = pg->pgn;
        prev->pg_next = NULL;
        free(pg);
        return 0;
    }

SAU (Ä‘Ã£ sá»­a):
    int find_victim_page(struct mm_struct *mm, addr_t *retpgn)
    {
        struct pgn_t *pg = mm->fifo_pgn;
        
        if (!pg) return -1;
        
        /* Special case: only one page in FIFO list */
        if (pg->pg_next == NULL) {
            *retpgn = pg->pgn;
            mm->fifo_pgn = NULL;  // List trá»‘ng sau khi remove
            free(pg);
            return 0;
        }
        
        /* Normal case: 2+ pages, find the last one */
        struct pgn_t *prev = NULL;
        while (pg->pg_next) {
            prev = pg;
            pg = pg->pg_next;
        }
        *retpgn = pg->pgn;
        prev->pg_next = NULL;
        free(pg);
        return 0;
    }

â“ Táº I SAO Lá»–I NÃ€Y Xáº¢Y RA TRONG TEST?
--------------------------------------
Lá»—i nÃ y xáº£y ra khi cháº¡y cÃ¡c test paging phá»©c táº¡p nhÆ° os_1_mlq_paging vÃ¬:

1. Nhiá»u process cÃ¹ng cháº¡y, sá»­ dá»¥ng nhiá»u RAM
2. RAM bá»‹ Ä‘áº§y -> cáº§n swap out pages
3. Má»™t process má»›i vá»«a allocate 1 page duy nháº¥t
4. Process khÃ¡c cáº§n RAM -> gá»i find_victim_page()
5. Náº¿u victim Ä‘Æ°á»£c chá»n tá»« process chá»‰ cÃ³ 1 page -> CRASH

Stack trace cho tháº¥y call flow:
    libwrite() -> pg_setval() -> pg_getpage() -> find_victim_page() -> CRASH

NghÄ©a lÃ : Khi write vÃ o má»™t Ä‘á»‹a chá»‰, cáº§n load page vÃ o RAM, nhÆ°ng RAM Ä‘áº§y
nÃªn pháº£i tÃ¬m victim Ä‘á»ƒ swap out, vÃ  victim process chá»‰ cÃ³ 1 page.

================================================================================
Tá»”NG Káº¾T Táº¤T Cáº¢ CÃC Lá»–I ÄÃƒ Sá»¬A (12 Lá»–I)
================================================================================

â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STT â”‚ MÃ” Táº¢ Lá»–I                                  â”‚ FILE                    â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1  â”‚ Thiáº¿u Ä‘á»‹nh nghÄ©a TABLE_SIZE_64             â”‚ include/mm64.h          â”‚
â”‚  2  â”‚ Sai truy cáº­p mm_struct (caller->mm)        â”‚ src/mm64.c              â”‚
â”‚  3  â”‚ Thiáº¿u trÆ°á»ng tracking trong mm_struct      â”‚ include/os-mm.h         â”‚
â”‚  4  â”‚ Sai kiá»ƒu tráº£ vá» (int thay vÃ¬ addr_t)       â”‚ src/mm64.c              â”‚
â”‚  5  â”‚ Typo PAGING64_PAGE_ALIGNSZ_64              â”‚ src/libmem.c            â”‚
â”‚  6  â”‚ Race condition trong ld_routine            â”‚ src/os.c                â”‚
â”‚  7  â”‚ print_pgtbl khÃ´ng in PDG= (vm_freerg_list) â”‚ src/mm64.c              â”‚
â”‚  8  â”‚ Segfault find_victim_page (1 page)         â”‚ src/libmem.c            â”‚
â”‚  9  â”‚ Sai format output (thá»«a debug info)        â”‚ src/mm64.c, libmem.c    â”‚
â”‚ 10  â”‚ print_pgtbl header trá»‘ng + race condition  â”‚ src/mm64.c, libmem.c    â”‚
â”‚ 11  â”‚ Processes share global krnl->mm            â”‚ common.h, os.c, libmem  â”‚
â”‚ 12  â”‚ sbrk khÃ´ng update sau allocation           â”‚ src/libmem.c            â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
Tá»”NG Káº¾T CÃC FILE ÄÃƒ Sá»¬A
================================================================================

1. include/mm64.h
   - ThÃªm: #define TABLE_SIZE_64 512

2. include/os-mm.h
   - ThÃªm cÃ¡c trÆ°á»ng tracking vÃ o struct mm_struct:
     + int used_pgd[512]
     + int used_p4d[512]
     + int used_pud[512]
     + int used_pmd[512]
     + unsigned long access_counter
     + unsigned long byte_counter

3. include/common.h
   - ThÃªm field mm vÃ o struct pcb_t: struct mm_struct *mm

4. src/mm64.c
   - Sá»­a caller->mm -> caller->krnl->mm (8 vá»‹ trÃ­) [Lá»—i 2]
   - Sau Ä‘Ã³ sá»­a ngÆ°á»£c láº¡i caller->krnl->mm -> caller->mm [Lá»—i 11]
   - Sá»­a kiá»ƒu tráº£ vá»: int -> addr_t cho 3 hÃ m
   - Sá»­a init_mm(): bá» khá»Ÿi táº¡o vm_freerg_list vá»›i toÃ n bá»™ khÃ´ng gian
   - Sá»­a print_pgtbl(): check start >= end trÆ°á»›c khi in header

5. src/libmem.c
   - Sá»­a typo: PAGING64_PAGE_ALIGNSZ_64 -> PAGING64_PAGE_ALIGNSZ
   - Sá»­a find_victim_page(): thÃªm xá»­ lÃ½ trÆ°á»ng há»£p FIFO list chá»‰ cÃ³ 1 page
   - Bá» dÃ²ng printf "Allocated %u bytes..." trong liballoc
   - Bá» print_pgtbl() trong libread (chá»‰ giá»¯ printf tÃªn hÃ m)
   - Sá»­a caller->krnl->mm -> caller->mm (táº¥t cáº£ vá»‹ trÃ­) [Lá»—i 11]
   - ThÃªm cur_vma->sbrk = old_sbrk + inc_sz sau allocation [Lá»—i 12]
   - ThÃªm fflush(stdout) sau cÃ¡c printf

6. src/os.c
   - Di chuyá»ƒn while loop lÃªn trÆ°á»›c load() trong ld_routine
   - ThÃªm proc->mm = malloc(...) cho má»—i process [Lá»—i 11]
   - Gá»i init_mm(proc->mm, proc) thay vÃ¬ init_mm(krnl->mm, proc)
   - Sá»­a cpu_routine: Pre-check logic Ä‘á»ƒ timing khá»›p expected [Lá»—i 13]
   - ThÃªm fflush(stdout) sau cÃ¡c printf

7. src/timer.c
   - ThÃªm fflush(stdout) sau printf Time slot

8. src/mm-vm.c
   - ThÃªm #include "mm64.h"
   - ThÃªm #ifdef MM64 cho PAGING64_PAGE_ALIGNSZ
   - Sá»­a caller->krnl->mm -> caller->mm [Lá»—i 11]

================================================================================
Lá»–I 13: SAI LOGIC CPU_ROUTINE - POST-CHECK VS PRE-CHECK
================================================================================

ğŸ“ File: src/os.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
cpu_routine sá»­ dá»¥ng POST-CHECK logic - kiá»ƒm tra Finished vÃ  time_left SAU 
khi cháº¡y run() nhÆ°ng TRÆ¯á»šC next_slot(). Äiá»u nÃ y lÃ m "Put process" vÃ  
"Dispatched process" xuáº¥t hiá»‡n TRÆ¯á»šC khi time slot thay Ä‘á»•i.

VÃ­ dá»¥ vá»›i POST-CHECK:
    Slot 5: libwrite
    Slot 5: Put process 1        â† In á»Ÿ slot 5 (ngay sau run)
    Slot 6: Dispatched process 3 â† In á»Ÿ slot tiáº¿p theo

Expected output muá»‘n:
    Slot 6: libwrite
    Slot 7: Put process 1        â† In á»Ÿ Ä‘áº§u slot 7
    Slot 7: Dispatched process 3 â† In cÃ¹ng slot 7

âœ… CÃCH Sá»¬A - PRE-CHECK LOGIC:
-----------------------------
Kiá»ƒm tra Finished vÃ  time_left á» Äáº¦U má»—i iteration (sau next_slot cá»§a 
iteration trÆ°á»›c):

    while (1) {
        /* === PRE-CHECK: At START of time slot === */
        if (proc != NULL) {
            if (proc->pc == proc->code->size) {
                /* Process finished - cleanup */
                printf("CPU %d: Processed %d has finished\n", id, proc->pid);
                fflush(stdout);
                free(proc);
                proc = NULL;
                time_left = 0;
            } else if (time_left == 0) {
                /* Time quantum expired - put back to run queue */
                printf("CPU %d: Put process %d to run queue\n", id, proc->pid);
                fflush(stdout);
                put_proc(proc);
                proc = NULL;
            }
        }
        
        /* Get new process if needed */
        if (proc == NULL) {
            proc = get_proc();
            if (proc == NULL) {
                if (done) break;
                next_slot(timer_id);
                continue;
            }
        }
        
        /* Dispatch if new quantum */
        if (time_left == 0) {
            printf("CPU %d: Dispatched process %d\n", id, proc->pid);
            fflush(stdout);
            time_left = time_slot;
        }
        
        /* Run current process */
        run(proc);
        time_left--;
        
        next_slot(timer_id);
    }

ğŸ’¡ GIáº¢I THÃCH:
--------------
- PRE-CHECK: Kiá»ƒm tra status á»Ÿ Äáº¦U slot â†’ Put/Dispatch in cÃ¹ng slot vá»›i nhau
- POST-CHECK: Kiá»ƒm tra status á»Ÿ CUá»I slot â†’ Put in riÃªng slot, Dispatch in slot sau

Flow vá»›i PRE-CHECK (Ä‘Ãºng vá»›i expected):
    Slot 1: Dispatch process 1
    Slot 2-6: Run process 1 (6 slots = quantum)
    Slot 7: Pre-check â†’ time_left==0 â†’ Put process 1 â†’ Get proc â†’ Dispatch process 3
    
Flow vá»›i POST-CHECK (sai):
    Slot 1: Get proc â†’ Dispatch process 1 â†’ Run â†’ next_slot
    Slot 2-5: Run process 1
    Slot 6 cuá»‘i: Run â†’ time_left==0 â†’ Put process 1 â†’ Get proc â†’ next_slot
    Slot 7: Dispatch process 3

================================================================================
Lá»–I 14: RACE CONDITION TRONG TIMER_ROUTINE - TIME SLOT IN SAU CPU
================================================================================

ğŸ“ File: src/timer.c

âŒ NGUYÃŠN NHÃ‚N:
--------------
Trong hÃ m timer_routine, thá»© tá»± thá»±c hiá»‡n lá»‡nh gÃ¢y ra race condition:

    Code cÅ© (gÃ¢y lá»—i):
    while (!timer_stop) {
        printf("Time slot %3lu\n", ...);  // 1. In Time slot á»Ÿ Äáº¦U vÃ²ng láº·p
        fflush(stdout);
        
        // ... chá» cÃ¡c thread bÃ¡o cÃ¡o xong ...
        
        _time++;                           // 2. TÄƒng thá»i gian
        
        pthread_cond_signal(...);          // 3. ÄÃ¡nh thá»©c CPU
        
        if (fsh == event) break;           // 4. Kiá»ƒm tra káº¿t thÃºc
    }

ğŸ‘‰ Háº­u quáº£:
1. Timer Ä‘Ã¡nh thá»©c CPU (bÆ°á»›c 3)
2. CPU thá»©c dáº­y vÃ  in "Put process..." ngay láº­p tá»©c
3. Timer chÆ°a ká»‹p quay láº¡i Ä‘áº§u vÃ²ng láº·p Ä‘á»ƒ in "Time slot..."
4. Output bá»‹ lá»™n xá»™n: CPU operations in TRÆ¯á»šC Time slot

ThÃªm vÃ o Ä‘Ã³, kiá»ƒm tra káº¿t thÃºc (fsh == event) á»Ÿ CUá»I vÃ²ng láº·p lÃ m in thá»«a
má»™t dÃ²ng Time slot cuá»‘i cÃ¹ng khi táº¥t cáº£ CPU Ä‘Ã£ dá»«ng.

âœ… CÃCH Sá»¬A:
------------
Äáº£o ngÆ°á»£c thá»© tá»±: In Time slot TRÆ¯á»šC khi Ä‘Ã¡nh thá»©c CPU, vÃ  kiá»ƒm tra 
káº¿t thÃºc TRÆ¯á»šC khi in Time slot má»›i:

    static void * timer_routine(void * args) {
        // 1. In Time slot 0 thá»§ cÃ´ng TRÆ¯á»šC khi vÃ o vÃ²ng láº·p
        printf("Time slot %3lu\n", current_time());
        fflush(stdout);
        
        while (!timer_stop) {
            // ... chá» cÃ¡c thread bÃ¡o cÃ¡o xong ...
            
            // 2. Kiá»ƒm tra káº¿t thÃºc TRÆ¯á»šC KHI in time slot má»›i
            if (fsh == event) {
                break;  // ThoÃ¡t ngay, khÃ´ng in thÃªm Time slot
            }
            
            // 3. TÄƒng thá»i gian
            _time++;
            
            // 4. In Time slot Má»šI TRÆ¯á»šC khi Ä‘Ã¡nh thá»©c ai
            printf("Time slot %3lu\n", current_time());
            fflush(stdout);
            
            // 5. ÄÃ¡nh thá»©c CPU (lÃºc nÃ y Time slot Ä‘Ã£ in rá»“i!)
            pthread_cond_signal(...);
        }
        pthread_exit(args);
    }

ğŸ’¡ GIáº¢I THÃCH:
--------------
Flow má»›i:
    1. Timer in "Time slot 9"
    2. Timer Ä‘Ã¡nh thá»©c CPU
    3. CPU thá»©c dáº­y, in "Put process 2"
    4. Output Ä‘Ãºng thá»© tá»±: Time slot 9 â†’ Put process 2

Flow cÅ© (lá»—i):
    1. Timer Ä‘Ã¡nh thá»©c CPU
    2. CPU cháº¡y nhanh, in "Put process 2"
    3. Timer quay láº¡i Ä‘áº§u vÃ²ng, in "Time slot 9"
    4. Output sai: Put process 2 â†’ Time slot 9

Viá»‡c kiá»ƒm tra (fsh == event) TRÆ¯á»šC khi in Time slot má»›i giÃºp:
- KhÃ´ng in Time slot thá»«a khi táº¥t cáº£ CPU Ä‘Ã£ dá»«ng
- Output káº¿t thÃºc Ä‘Ãºng: "CPU X stopped" lÃ  dÃ²ng cuá»‘i, khÃ´ng cÃ³ Time slot sau

================================================================================
SO SÃNH OUTPUT METRICS
================================================================================

Test: os_0_mlq_paging

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Metric          â”‚ Expected â”‚ Actual â”‚ Match â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Lines           â”‚ 78       â”‚ 78     â”‚ âœ…    â”‚
â”‚ Dispatched      â”‚ 9        â”‚ 9      â”‚ âœ…    â”‚
â”‚ Put process     â”‚ 5        â”‚ 5      â”‚ âœ…    â”‚
â”‚ Finished        â”‚ 4        â”‚ 4      â”‚ âœ…    â”‚
â”‚ Loaded          â”‚ 4        â”‚ 4      â”‚ âœ…    â”‚
â”‚ liballoc        â”‚ 3        â”‚ 3      â”‚ âœ…    â”‚
â”‚ libfree         â”‚ 2        â”‚ 2      â”‚ âœ…    â”‚
â”‚ libread         â”‚ 3        â”‚ 3      â”‚ âœ…    â”‚
â”‚ libwrite        â”‚ 3        â”‚ 3      â”‚ âœ…    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
GHI CHÃš Vá»€ RACE CONDITIONS
================================================================================

Má»™t sá»‘ khÃ¡c biá»‡t nhá» trong output lÃ  CHáº¤P NHáº¬N ÄÆ¯á»¢C do báº£n cháº¥t cá»§a 
multi-threaded system:

1. CPU numbers (CPU 0 vs CPU 1):
   â†’ Do OS thread scheduler quyáº¿t Ä‘á»‹nh, khÃ´ng thá»ƒ control

2. Thá»© tá»± output trong cÃ¹ng time slot:
   â†’ Race condition giá»¯a cÃ¡c thread khi cÃ¹ng gá»i printf()

3. Äá»‹a chá»‰ PDG= khÃ¡c nhau:
   â†’ Do dynamic memory allocation address

Nhá»¯ng khÃ¡c biá»‡t nÃ y KHÃ”NG áº£nh hÆ°á»Ÿng Ä‘áº¿n tÃ­nh Ä‘Ãºng Ä‘áº¯n cá»§a chÆ°Æ¡ng trÃ¬nh
vÃ¬ táº¥t cáº£ operations Ä‘á»u Ä‘Æ°á»£c thá»±c hiá»‡n Ä‘Ãºng vÃ  Ä‘á»§ sá»‘ lÆ°á»£ng.

================================================================================
Tá»”NG Káº¾T CÃC FILE ÄÃƒ Sá»¬A
================================================================================

1. include/mm64.h
   - ThÃªm Ä‘á»‹nh nghÄ©a TABLE_SIZE_64 = 512

2. include/os-mm.h
   - ThÃªm cÃ¡c trÆ°á»ng: pgd_start, p4d_start, pud_start, pmd_start, pt_start
   - ThÃªm pthread_mutex_t mm_lock

3. include/common.h
   - ThÃªm struct mm_struct *mm vÃ o pcb_t [Lá»—i 11]

4. src/mm64.c
   - Sá»­a kiá»ƒu tráº£ vá»: int -> addr_t
   - Sá»­a print_pgtbl Ä‘á»ƒ in Ä‘Ãºng format
   - Sá»­a caller->krnl->mm -> caller->mm [Lá»—i 11]

5. src/libmem.c
   - Sá»­a typo: PAGING64_PAGE_ALIGNSZ_64 -> PAGING64_PAGE_ALIGNSZ
   - Sá»­a find_victim_page(): xá»­ lÃ½ FIFO list 1 page
   - Bá» printf dÆ° thá»«a
   - Sá»­a caller->krnl->mm -> caller->mm [Lá»—i 11]
   - ThÃªm cur_vma->sbrk = old_sbrk + inc_sz [Lá»—i 12]

6. src/os.c
   - Sá»­a ld_routine: chá» Ä‘Ãºng time slot trÆ°á»›c load
   - ThÃªm proc->mm allocation [Lá»—i 11]
   - Sá»­a cpu_routine: Pre-check logic [Lá»—i 13]

7. src/timer.c
   - In Time slot 0 trÆ°á»›c vÃ²ng láº·p [Lá»—i 14]
   - In Time slot sau _time++ vÃ  trÆ°á»›c pthread_cond_signal [Lá»—i 14]
   - Kiá»ƒm tra fsh == event trÆ°á»›c khi in Time slot má»›i [Lá»—i 14]

8. src/mm-vm.c
   - ThÃªm #include "mm64.h"
   - Sá»­a caller->krnl->mm -> caller->mm [Lá»—i 11]

================================================================================
                                    Háº¾T
================================================================================
